import logging
from pydantic import BaseModel, Field, PrivateAttr, model_validator
from fastapi import FastAPI, HTTPException
from langchain_core.runnables import Runnable

from src.core import AppSession
from src.ai import BlogAgent, Blog, LLMManager

logger = logging.getLogger(__name__)


class BlogRequest(BaseModel):
    """
    Class for Blog API request payload.
    
    Attributes:
        topic: The user's blog topic or query
        language: Language code for blog generation (e.g., 'en', 'es', 'fr')
    """

    topic: str = Field(
        ..., 
        description="The user query for the blog generation request",
        min_length=3
    )
    
    language: str = Field(
        default="en", 
        description="The language code to generate the blog (defaults to English)",
        min_length=2,
        max_length=5
    )


class BlogResponse(BaseModel):
    """
    Response model for blog generation endpoint.
    
    Attributes:
        topic: The original requested topic
        blog: Generated blog with title and content
    """
    
    topic: str = Field(
        ..., 
        description="The requested topic from the user"
    )
    blog: Blog = Field(
        ..., 
        description="A blog object generated by the LLM"
    )


# API module

class BlogAPIManager(BaseModel):
    """
    A manager class that encapsulates FastAPI app and blog generation logic.
    
    This class initializes and manages the blog generation API, including
    LLM configuration, agent setup, and route registration. It provides
    a complete FastAPI application ready to serve blog generation requests.
    """
    
    # Configuration fields (can be set by caller)
    model_name: str = Field(
        default="openai/gpt-oss-120b", 
        description="LLM model name (e.g., 'llama-3.3-70b-versatile')"
    )
    model_provider: str = Field(
        default="groq", 
        description="LLM provider (e.g., 'groq', 'openai', 'anthropic')"
    )
    base_url: str | None = Field(
        default=None,
        description="Optional base URL for the AI gateway or custom endpoint"
    )
    ai_API_key: str = Field(
        ...,
        description="The API key for the AI service"
    )
    api_title: str = Field(
        default="BlogForge API", 
        description="API title"
    )
    api_description: str = Field(
        default="AI-powered blog generation service", 
        description="API description"
    )
    
    app_session: AppSession = Field(
        ...,
        description="App session instance"
    )
    
    # Private attributes for internal state
    _llm_manager: LLMManager = PrivateAttr()
    _agent: Runnable = PrivateAttr()
    _api: FastAPI = PrivateAttr()
    
    @model_validator(mode="after") 
    def _post_init(self) -> "BlogAPIManager":
        """
        Initialize the API manager after model validation.
        
        Sets up the LLM manager, blog agent, and FastAPI application
        with all configured parameters.
        
        Returns:
            The initialized BlogAPIManager instance
        """
        # Initialize LLM and agent with configurable parameters
        self._llm_manager = LLMManager(
            model=self.model_name, 
            model_provider=self.model_provider,
            base_url=self.base_url,
            ai_API_key=self.ai_API_key
        )
        self._agent = BlogAgent(
            llm=self._llm_manager.llm, 
            app_session=self.app_session
        ).agent
        
        # Create FastAPI instance with configurable metadata
        self._api = FastAPI(
            title=self.api_title,
            description=self.api_description,
            version="1.0.0"
        )
        self._register_routes()
        
        return self
    
    @property
    def api(self) -> FastAPI:
        """Get the FastAPI instance"""
        return self._api
    
    def _register_routes(self):
        """Register all API routes"""
        
        @self._api.post("/blog/", response_model=BlogResponse)
        async def generate_blog(request: BlogRequest):
            """
            Generate a blog based on the provided topic and language.
            
            Args:
                request: Blog generation request with topic and language
                
            Returns:
                BlogResponse with the generated blog content
                
            Raises:
                HTTPException: 400 for invalid input, 500 for generation errors
            """
            if not request.topic or not request.topic.strip():
                raise HTTPException(
                    status_code=400, 
                    detail="Invalid request: topic field cannot be empty"
                )

            try:
                logger.info(f"Generating blog for topic: '{request.topic}', language: '{request.language}'")
                response = self._agent.invoke({
                    "topic": request.topic.strip(), 
                    "language": request.language
                })

                return BlogResponse(
                    topic=request.topic, 
                    blog=response["blog"]
                )

            except Exception as e:
                logger.error(f"Failed to generate blog for topic '{request.topic}': {e}")
                raise HTTPException(
                    status_code=500, 
                    detail=f"Blog generation failed: {str(e)}"
                )